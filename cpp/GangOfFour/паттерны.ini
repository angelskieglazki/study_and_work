Паттерны:

Одиночка (Singleton) - гарантирует, что класс имеет только один экземпляр и обеспечивает глобальную точку доступа к этому экземпляру.

Фабрика (Factory) - используется для создания объектов без необходимости знать конкретный класс объекта.

Абстрактная фабрика (Abstract Factory) - предоставляет интерфейс для создания семейств взаимосвязанных объектов без указания их конкретных классов.

Строитель (Builder) - используется для создания сложных объектов с помощью пошагового конструирования.

Декоратор (Decorator) - позволяет динамически добавлять новую функциональность существующим объектам.

Прокси (Proxy) - позволяет управлять доступом к объекту, обеспечивая дополнительный уровень косвенности.

Адаптер (Adapter) - позволяет использовать классы с несовместимыми интерфейсами вместе.

Компоновщик (Composite) - позволяет создавать древовидные структуры объектов и работать с ними как с одним целым.

Итератор (Iterator) - предоставляет способ последовательного доступа к элементам коллекции без раскрытия ее внутреннего представления.

* Наблюдатель (Observer) - позволяет объектам получать уведомления об изменениях в других объектах.

Шаблонный метод (Template Method) - определяет основу для алгоритма и позволяет подклассам переопределять определенные шаги.

Стратегия (Strategy) - позволяет выбирать из набора алгоритмов во время выполнения программы.

Цепочка обязанностей (Chain of Responsibility) - позволяет передавать запросы последовательно по цепочке обработчиков.

Фасад (Facade) - предоставляет простой интерфейс к сложной системе классов.

* Снимок (Memento) - позволяет сохранять и восстанавливать предыдущее состояние объекта.

Приспособленец (Flyweight) - используется для эффективного обращения с большим количеством мелких объектов.

Мост (Bridge) - разделяет абстракцию от ее реализации, позволяя им изменяться независимо друг от друга.

Кеширование (Caching) - используется для сохранения результатов операций или данных, чтобы ускорить доступ к ним в будущем.

Состояние (State) - позволяет объекту изменять свое поведение в зависимости от своего внутреннего состояния.

Посетитель (Visitor) - позволяет добавлять новые операции к объектам без изменения их классов.

Параметрический полиморфизм (CRTP) - позволяет достичь статического полиморфизма через использование наследования от шаблонного базового класса.

Аспектно-ориентированное программирование (Aspect-Oriented Programming, AOP) - позволяет выносить повторяющиеся аспекты кода в отдельные модули, независимо от основной структуры программы.

Инверсия управления (Inversion of Control, IoC) - позволяет отделить создание и связывание объектов от их использования, облегчая расширение и замену компонентов.

Шаблонный проектировщик (Template Designer) - используется для создания объектов, которые могут быть настроены с помощью шаблонов.

* Пул объектов (Object Pool) - предварительно создает и поддерживает пул объектов для повторного использования, вместо создания новых объектов.


Идиомы:
Я знаю несколько идиом программирования на C++. Вот некоторые из них:

RAII (Resource Acquisition Is Initialization) - это идиома, которая заключается в том, что приобретение ресурсов, таких как динамические объекты памяти, происходит в конструкторе объекта, а освобождение ресурсов происходит в деструкторе объекта.

Pimpl (Pointer to Implementation) - это идиома, которая заключается в том, что определение частного члена класса (implementation) выносится за пределы класса, и к нему можно получить доступ только через указатель.

SFINAE (Substitution Failure Is Not An Error) - это идиома, которая используется для выбора перегруженной функции на основе типа аргументов. Если компилятор не может выполнить подстановку шаблона для данного типа, он просто игнорирует эту перегрузку функции.

CRTP (Curiously Recurring Template Pattern) - это идиома, которая позволяет имитировать наследование от базового класса, используя шаблонные параметры и наследование через шаблоны. Она часто используется для создания статической полиморфной иерархии.

NVI (Non-Virtual Interface) - это идиома, которая заключается в том, что публичный интерфейс класса не содержит виртуальных функций, а вместо этого используются защищенные виртуальные функции, которые вызываются в публичных не виртуальных функциях.

CTR (Constructor-based Type Recognition) - это идиома, которая используется для определения типа объекта во время компиляции путем использования информации о конструкторе объекта. Это может быть полезно для создания шаблонных классов, которые могут работать с различными типами.

RAII-On-Heap - это идиома, которая используется для управления ресурсами на куче (heap), основанная на RAII. Она предлагает класс-обертку, который приобретает ресурс при создании и освобождает его при уничтожении, но вместо того, чтобы выделять память в стеке, он выделяет память на куче.

----------------------------------------

комбинация паттернов наблюдатель, посредник и шаблонный метод