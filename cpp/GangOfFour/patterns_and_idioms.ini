Паттерны:

Одиночка (Singleton) - гарантирует, что класс имеет только один экземпляр и обеспечивает глобальную точку доступа к этому экземпляру.

Фабрика (Factory) - используется для создания объектов без необходимости знать конкретный класс объекта.

Абстрактная фабрика (Abstract Factory) - предоставляет интерфейс для создания семейств взаимосвязанных объектов без указания их конкретных классов.

Строитель (Builder) - используется для создания сложных объектов с помощью пошагового конструирования.

Декоратор (Decorator) - позволяет динамически добавлять новую функциональность существующим объектам.

Прокси (Proxy) - позволяет управлять доступом к объекту, обеспечивая дополнительный уровень косвенности.

Адаптер (Adapter) - позволяет использовать классы с несовместимыми интерфейсами вместе.

Компоновщик (Composite) - позволяет создавать древовидные структуры объектов и работать с ними как с одним целым.

Итератор (Iterator) - предоставляет способ последовательного доступа к элементам коллекции без раскрытия ее внутреннего представления.

* Наблюдатель (Observer) - позволяет объектам получать уведомления об изменениях в других объектах.

Шаблонный метод (Template Method) - определяет основу для алгоритма и позволяет подклассам переопределять определенные шаги.

Стратегия (Strategy) - позволяет выбирать из набора алгоритмов во время выполнения программы.

Цепочка обязанностей (Chain of Responsibility) - позволяет передавать запросы последовательно по цепочке обработчиков.

Фасад (Facade) - предоставляет простой интерфейс к сложной системе классов.

* Снимок (Memento) - позволяет сохранять и восстанавливать предыдущее состояние объекта.

Приспособленец (Flyweight) - используется для эффективного обращения с большим количеством мелких объектов.

Мост (Bridge) - разделяет абстракцию от ее реализации, позволяя им изменяться независимо друг от друга.

Кеширование (Caching) - используется для сохранения результатов операций или данных, чтобы ускорить доступ к ним в будущем.

Состояние (State) - позволяет объекту изменять свое поведение в зависимости от своего внутреннего состояния.

Посетитель (Visitor) - позволяет добавлять новые операции к объектам без изменения их классов.

Параметрический полиморфизм (CRTP) - позволяет достичь статического полиморфизма через использование наследования от шаблонного базового класса.

Аспектно-ориентированное программирование (Aspect-Oriented Programming, AOP) - позволяет выносить повторяющиеся аспекты кода в отдельные модули, независимо от основной структуры программы.

Инверсия управления (Inversion of Control, IoC) - позволяет отделить создание и связывание объектов от их использования, облегчая расширение и замену компонентов.

Шаблонный проектировщик (Template Designer) - используется для создания объектов, которые могут быть настроены с помощью шаблонов.

* Пул объектов (Object Pool) - предварительно создает и поддерживает пул объектов для повторного использования, вместо создания новых объектов.


Идиомы:
Я знаю несколько идиом программирования на C++. Вот некоторые из них:

RAII (Resource Acquisition Is Initialization) - это идиома, которая заключается в том, что приобретение ресурсов, таких как динамические объекты памяти, происходит в конструкторе объекта, а освобождение ресурсов происходит в деструкторе объекта.

Pimpl (Pointer to Implementation) - это идиома, которая заключается в том, что определение частного члена класса (implementation) выносится за пределы класса, и к нему можно получить доступ только через указатель.

SFINAE (Substitution Failure Is Not An Error) - это идиома, которая используется для выбора перегруженной функции на основе типа аргументов. Если компилятор не может выполнить подстановку шаблона для данного типа, он просто игнорирует эту перегрузку функции.

CRTP (Curiously Recurring Template Pattern) - это идиома, которая позволяет имитировать наследование от базового класса, используя шаблонные параметры и наследование через шаблоны. Она часто используется для создания статической полиморфной иерархии.

NVI (Non-Virtual Interface) - это идиома, которая заключается в том, что публичный интерфейс класса не содержит виртуальных функций, а вместо этого используются защищенные виртуальные функции, которые вызываются в публичных не виртуальных функциях.

CTR (Constructor-based Type Recognition) - это идиома, которая используется для определения типа объекта во время компиляции путем использования информации о конструкторе объекта. Это может быть полезно для создания шаблонных классов, которые могут работать с различными типами.

RAII-On-Heap - это идиома, которая используется для управления ресурсами на куче (heap), основанная на RAII. Она предлагает класс-обертку, который приобретает ресурс при создании и освобождает его при уничтожении, но вместо того, чтобы выделять память в стеке, он выделяет память на куче.

Acyclic Visitor Pattern TODO
Address Of 75% developed  as of 9 October 2011
Algebraic Hierarchy 75% developed  as of 12 June 2008
Attach by Initialization 75% developed  as of 22 October 2011
Attorney-Client 75% developed  as of 9 October 2011
Barton-Nackman trick 75% developed  as of 21 February 2011
Base-from-Member 75% developed  as of 6 August 2007
Boost mutant 75% developed  as of 9 May 2010
Calling Virtuals During Initialization 75% developed  as of 6 August 2007
Capability Query 100% developed  as of 21 February 2011
Checked delete 75% developed  as of 15 August 2007
Clear-and-minimize 75% developed  as of 10 August 2007
Coercion by Member Template 100% developed  as of 14 August 2007
Computational Constructor 75% developed  as of 9 October 2011
Concrete Data Type 75% developed  as of 17 March 2008
Construct On First Use 75% developed  as of 6 August 2007
Construction Tracker 75% developed  as of 6 August 2007
Copy-and-swap 75% developed  as of 10 August 2007
Copy-on-write 100% developed  as of 20 May 2009
Thread-safe Copy-on-write 100% developed  as of 20 May 2009
Intrusive reference counting (Counted Body) 75% developed  as of 16 November 2007
Covariant Return Types TODO
Curiously Recurring Template Pattern (CRTP) 75% developed  as of 6 August 2007
Deprecate and Delete TODO
Empty Base Optimization (EBO) 75% developed  as of 9 October 2011
enable-if 75% developed  as of 21 Feb 2011
Erase-Remove 75% developed  as of 17 November 2007
Execute-Around Pointer 75% developed  as of 6 August 2007
Exploding Return Type TODO
Export Guard Macro TODO
Expression-template 75% developed  as of 6 August 2007
Fake Vtable TODO
Fast Pimpl 0% developed  as of 6 August 2007 TODO
Final Class 75% developed  as of 10 May 2010
Free Function Allocators75% developed  as of 18 June 2014
Function Object TODO
Function Poisoning TODO
Generic Container Idioms 75% developed  as of 22 November 2007
Hierarchy Generation TODO
Implicit conversions TODO
Include Guard Macro 75% developed  as of 3 November 2007
Inline Guard Macro 75% developed  as of 3 November 2007
Inner Class 75% developed  as of 31 August 2007
Int-To-Type 75% developed  as of 21 September 2008
Interface Class 75% developed  as of 6 January 2008
Iterator Pair 100% developed  as of 28 October 2007
Making New Friends 75% developed  as of 5 January 2008
Metafunction 75% developed  as of 15 September 2008
Move Constructor 100% developed  as of 13 August 2007
Multi-statement Macro 75% developed  as of 16 February 2008
+++ Member Detector 75% developed  as of 10 May 2010
Named Constructor 75% developed  as of 28 September 2008
Named External Argument TODO
Named Loop (labeled loop) 75% developed  as of 9 May 2010
Named Parameter 75% developed  as of 11 May 2010
Named Template Parameters TODO
Nifty Counter (Schwarz Counter) 75% developed  as of 6 August 2007
Non-copyable Mixin 75% developed  as of 6 August 2007
Non-member Non-friend Function 0% developed  as of 10 March 2008 TODO
Non-throwing swap 75% developed  as of 9 January 2008
Non-Virtual Interface (NVI, Public Overloaded Non-Virtuals Call Protected Non-Overloaded Virtuals) 75% developed  as of 12 June 2008
nullptr 75% developed  as of 3 November 2007
Object Generator 75% developed  as of 14 September 2008
Object Template TODO
Parameterized Base Class (Parameterized Inheritance) 75% developed  as of 6 August 2007
Pimpl (Handle Body, Compilation Firewall, Cheshire Cat) 0% developed  as of 2 March 2011
Policy Clone (Metafunction wrapper) 100% developed  as of 14 August 2007
Policy-based Design TODO
Polymorphic Exception 75% developed  as of 28 September 2008
Polymorphic Value Types 0% developed  as of 24 June 2012 TODO
Recursive Type Composition TODO
Requiring or Prohibiting Heap-based Objects
Resource Acquisition Is Initialization (RAII, Execute-Around Object, Scoped Locking) 100% developed  as of 6 November 2007
Resource Return 75% developed  as of 3 November 2007
Return Type Resolver 75% developed  as of 10 May 2010
Runtime Static Initialization Order Idioms 75% developed  as of 6 August 2007
Safe bool 75% developed  as of 6 August 2007
Scope Guard 100% developed  as of 14 August 2007
Substitution Failure Is Not An Error (SFINAE) 75% developed  as of 12 May 2012
Shortening Long Template Names TODO
Shrink-to-fit 75% developed  as of 10 August 2007
Small Object Optimization TODO
Smart Pointer 75% developed  as of 17 November 2007
Storage Class Tracker TODO
Tag Dispatching 0% developed  as of 21 October 2007 TODO
Temporary Base Class 75% developed  as of 6 August 2007
Temporary Proxy 75% developed  as of 6 August 2007
The result_of technique TODO
Thin Template 75% developed  as of 6 August 2007
Thread-Safe Interface TODO
Traits 0% developed  as of 21 October 2007 TODO
Type Erasure 75% developed  as of 4 February 2015
Type Generator (Templated Typedef) 75% developed  as of 14 September 2008
Type Safe Enum 75% developed  as of 11 May 2010
Type Selection 75% developed  as of 9 May 2010
Virtual Constructor 75% developed  as of 17 March 2008
Virtual Friend Function 75% developed  as of 10 May 2010

Guarded suspension
Monitor Object
thread Pool
Reactor
Active object
balking
leaders/followers